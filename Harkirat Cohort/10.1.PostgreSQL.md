# Postgres

Types of databases: 
- Key-Value
- Documents
- Graph
- Vector Database

### NoSQL
NoSQL databases are designed to store, retrieve, and manage large volumes of unstructured or semi-structured data. Unlike SQL databases, NoSQL databases do not require a predefined schema.
Ideal for data that may not fit neatly into a relational model.
Eg: MongoDB, Cassandra, Redis, Couchbase.

Database have many collection and each collection have many documents.

**GraphD Database**
Graph databases are designed to store and navigate relationships. They treat the relationships between data as equally important as the data itself.
Data is stored in nodes (entities) and edges (relationships), which makes them highly efficient for traversing and querying complex relationships.
Particularly useful for social networks, recommendation engines, fraud detection, and any domain where relationships are key.
Eg: Neo4j, Amazon Neptune, OrientDB.

**Vector Database**
Vector databases are specialized databases optimized for vector similarity searching. They are used to store and process vector embeddings typically generated by machine learning models.
Data is stored in the form of vectors, which are arrays of numbers that represent data in a high-dimensional space.
Eg: Pinecone, Milvus, Faiss.

**SQL Databases**
SQL databases, store data in predefined schemas and tables with rows and columns.
Data is organized into tables, and each row in a table represents a record with a unique identifier called the primary key.
Most full-stack applications use SQL databases for their ability to maintain ACID (Atomicity, Consistency, Isolation, Durability) properties, ensuring reliable transaction processing.
Eg: MySQL, PostgreSQL, Oracle, SQL Server.


- NoSql is used beacause it allows for the storage of heterogeneous data and can accommodate changes in the data model without requiring migrations or alterations to the existing data structure.
- Without a uniform structure, data can become inconsistent.

>
SQL have database which have tables, in that rows and columns.
NoSQL have database which have collections, in that documents, in that fields.
>


Mongoose Schemas: Mongoose is an Object Data Modeling (ODM) library for MongoDB that allows developers to define schemas at the application level.
Mongoose enforces schema rules in the application code, it does not impose these constraints at the database level. MongoDB itself remains schemaless.


## SQL
- SQL approach to data management offers several advantages, particularly in terms of data integrity, consistency, and reliability.
- Before inserting data into an SQL database, you must define a schema. This schema dictates the structure of the data, including the tables, columns, data types, and relationships between tables(relationships between tables are strictly enforced).
- As your application evolves, you may need to update the database schema. This typically involves performing migrations—carefully managed changes that may add, remove, or alter tables and columns without losing data.
- An SQL database runs on a database server, which can be hosted locally on your development machine, on-premises in your data center, or in the cloud.
- To interact with an SQL database, you typically use a library or an ORM
- Before you can store data, you need to create tables and define their schema. This includes specifying the columns, data types, primary keys, foreign keys, and any constraints to enforce data integrity.
- SQL databases are designed to guarantee ACID (Atomicity, Consistency, Isolation, Durability) properties, making them ideal for applications that require transactions to be processed reliably.
- The SQL language provides powerful querying capabilities, allowing for complex data retrieval that can involve multiple tables and conditions.




**Creating a PostgreSQL DB**:
- You can use Neon DB and get connection string.
- You can use Docker locally. Docker allows you to run PostgreSQL in an isolated container on your local machine. Ensure Docker Desktop for Windows is installed and running.
    - Use this command "docker run --name my-postgres -e POSTGRES_PASSWORD=mysecretpassword -d -p 5432:5432 postgres"
    - Connection String looks like this - "postgresql://postgres:mysecretpassword@localhost:5432/postgres?sslmode=disable"
    - If the image is already downloaded, you can start the container with: "docker start my-postgres"
    - To connect to PostgreSQL instance, use: "docker exec -it my-postgres psql -U postgres -d postgres"
    - Enter the password when prompted to access the PostgreSQL command line interface.
    - Inside the PostgreSQL CLI, you can list all tables with: "/dt"
    - Connection String Format: "postgresql://[user]:[password]@[host]:[port]/[database]?[options]"



### Interacting with postgresql
It's common to use libraries or tools that facilitate connecting to, interacting with, and visualizing the data within these databases. Two such tools are `psql` and `pg`.

## psql
- psql is a command-line interface (CLI) tool that allows you to interact with a PostgreSQL database server.
- It provides a terminal-based front-end to PostgreSQL, enabling users to execute SQL queries directly, inspect the database schema, and manage the database.
To connect to database using psql: "psql -h [host] -d [database] -U [user]"
`h` specifies the host of the database server, `d` specifies the name of the database you want to connect to, and `U` specifies the username.

## pg (node-postgres)
- how mongoose is used for MongoDB, pg allows for interaction with PostgreSQL databases within a Node.js application.
- "npm install pg"
- connect to your PostgreSQL database using the pg library by creating a client and connecting it with your database's connection string:
```jsx
    const client = new Client({
        connectionString: 'YourDatabaseConnectionStringHere'
    });

    client.connect();
```
- pg provides a programmatic way to connect to and interact with your PostgreSQL database

- Creating a table in SQL
    - "CREATE TABLE users"
- Column Definition: Each column in the table is defined with a name, data type, and possibly one or more constraints.
    - "id SERIAL PRIMARY KEY"
    - "username VARCHAR(50) UNIQUE NOT NULL:"
    - "email VARCHAR(255) UNIQUE NOT NULL:"
    - "password VARCHAR(255) NOT NULL:"
    - "created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP"
- Execute the CREATE TABLE Command:
    - "CREATE TABLE users ();" And put the queries you have seen in this function to make a table users
- After running the command, you can verify the creation of the table by executing "\dt;" in the psql command-line interface.



Interacting with a database typically involves performing four fundamental operations, collectively known as CRUD operations: Create, Read, Update, and Delete.
- **INSERT (Create)**
```jsx
    INSERT INTO users (username, email, password)
    VALUES ('username_here', 'user@example.com', 'user_password');
```

- **UPDATE**
```jsx
    UPDATE users
    SET password = 'new_password'
    WHERE email = 'user@example.com';
```
    - The **WHERE** clause is crucial as it determines which records are updated. Without it, all records in the table would be updated.

- **DELETE**
```jsx
    DELETE FROM users
    WHERE id = 1;
```
    - Like with UPDATE, the WHERE clause specifies which records to delete. Omitting the WHERE clause would result in deleting all records in the table.

- **SELECT (Read)**
```jsx
    SELECT * FROM users
    WHERE id = 1;
```
    - The SELECT statement is highly versatile, allowing for complex queries with various conditions, sorting, and joining multiple tables.


>
Running Commands: If you have psql installed locally, you can run these commands directly in your terminal to interact with your PostgreSQL database.
>




### **Querying the Database**

Once connected, you can execute queries using the `query`method of the `Client` instance. Here's how to perform the four basic database operations:

- **Creating a Table**
```jsx
    async function createUsersTable() {
    await client.connect();
    const result = await client.query(`
        CREATE TABLE users (
            id SERIAL PRIMARY KEY,
            username VARCHAR(50) UNIQUE NOT NULL,
            email VARCHAR(255) UNIQUE NOT NULL,
            password VARCHAR(255) NOT NULL,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        );
    `);
    console.log(result);
    await client.end();
    }

    createUsersTable();
```

- **INSERT**
```jsx
    const insertResult = await client.query(
        "INSERT INTO users (username, email, password) VALUES ('username_here', 'user@example.com', 'user_password');"
    );
    console.log(insertResult);
```
​
- **UPDATE**
```jsx
    const updateResult = await client.query(
        "UPDATE users SET password = 'new_password' WHERE email = 'user@example.com';"
    );
    console.log(updateResult);
```

- **DELETE**
```jsx
    const deleteResult = await client.query(
        "DELETE FROM users WHERE id = 1;"
    );
    console.log(deleteResult);
```

- **SELECT**
```jsx
    const selectResult = await client.query(
        "SELECT * FROM users WHERE id = 1;"
    );
    console.log(selectResult.rows);
```



npm init -y
npx tsc --init
in tsconfig.json do this:-
"rootDir": "./src"
"outDir": "./dist"
npm install pg
npm install @types/pg --save-dev

Insert Data Function
```tsx
    const insertQuery = "INSERT INTO users (username, email, password) VALUES ($1, $2, $3)";
    const values = [username, email, password];
    const res = await client.query(insertQuery, values);
```

Fetch Data Function
```tsx
    const query = 'SELECT * FROM users WHERE email = $1';
    const values = [email];
    const result = await client.query(query, values);
```

>
This demonstrates how to set up a TypeScript project for a Node.js application that interacts with a PostgreSQL database using the pg library. By using parameterized queries, you can securely insert and fetch data, protecting your application from SQL injection attacks.
>