### Backend Communication

- Backend talking to another backend. Why? 
- Because as your app grows, you dont want to keep everything in a single server that is exposed over the internet.
- There's something called asynchronous processes. See, lets say the notification/sms/email you from gooogle pay after transfer, the primary backend server thats handling the core of business, should not be worried about this. The actual transfer needs to happen in this primary backend.
- Eg: Analytics, the primary backend server shouldnt be worried about tracking how many requests are coming. 
The things that are not a core part of the process, things that even if they happens after some time, its fine.

- So the core system backend handling the req of user with core things that they need instantly. And then a bunch of backend processes handling asynchronous requests. These asynchronous processes usually run on different server and the primary server needs to talk to them.

This is how a general backend architected, you don't put everything in a single place, there are a bunch of Micro Services talk to each other you don't have one monolith you don't have one very big server.

![alt text](Screenshot_2024-04-06_at_4.13.28_PM.webp)

So should the main backend service talk to the aggregator service via http call or should it put the request in the queue and then it sends to the aggregator serviceor it should use a websocket or pub sub(publisher-subscriber).

Ex: in the propayn application we have made the main backend talk to the database for changes of balance but if it's about sending the notification or phone sms or email then it puts the request in the queue.

Ex: in leet code, the main backend doesnt evaluate the users code, rather it sends it to the queue to some separate servers:
![alt text](Screenshot_2024-04-06_at_4.22.46_PM.webp)


Types of communication:
- Synchronous (Strong coupling): One system is directly pinging the other system, and waiting for the response/acknowledgement
    - HTTPS (REST/GraphQL)
    - Websocket (debatable if sync or async)
 
- Asynchronous (Weak coupling)- service dont wait for acknowledgement, service move on and do other thing
    - Messaging queues
    - Pub subs
    - Server-Sent Events 
    - Websocket (debatable if sync or async)

Websockets, when you have a websockets connection, you send the other side data, you dont wait for acknowledgement.

## Websockets
Websockets provide a way to establish a persistent, full-duplex communication channel over a single TCP connection between the client (typically a web browser) and the server.
Here the browser communicates to the server, but this is what http does. Here's a difference, the http connection you send a req to server and server responds and then connection close. But websockets connection is persistent. A lot of connection Needs to happen between the client and the server let's create one single connection the client and server sends events to each other thats websockets.
In http the server cant find the browser, the browser finds the server by hitting a certain endpoint.
Usecase: Lets say backpack exchange website, so many things are happening here and there. If you use http then many req needs to send and get the response. Every time you have to make a handshake. There is a lot of overhead you have to send and get back.
This is why you use websockets, the handshake happens only once and data sending happens both ways. You can see a websocket connection going to console. Its like just create a single connection and tell the server that keep sending me messages.

Use Cases for WebSockets:
- Real-Time Applications: Chat applications, live sports updates, real-time gaming, and any application requiring instant updates can benefit from WebSockets.
- Live Feeds: Financial tickers, news feeds, and social media updates are examples where WebSockets can be used to push live data to users.
- Interactive Services: Collaborative editing tools, live customer support chat, and interactive webinars can use WebSockets to enhance user interaction

Why not use HTTP/REST? Why do you need ws?
- Network Handshake happens for every request
- No way to push server side events (You can use polling but not the best approach)

#### Creating a websocket server
In nodejs, used express, koa, hono, these are all implementations of http protocol.
Similarly websockets is also a standard you can read about how a websocket server be on IETF tools RFC 6455 - the websocket protocol.

When you are in a trading company if you ever join James Street if you know the Youtuber called Joma Tech, he used to work at some trading company. His task was to go to this IETF read about the protocol and implement it from scratch in C. A lot of time companies that really care about latencies of system talking to each other, will build a websocket server from scratch in some low level language but we will highly depend on someone else's, who has written all of that code in javascript we are using a library that's on npm.

Popular implementations:
- npm websocket
- github websockets ws
- socket.io : Its easy to use but you should avoid it and stick to core websocket protocol.

- If You are creating a socket.io server it is good to use with website but if you are creating an Android app or a Rust app then you need to create socket.io implementation for those as well separately.
It's harder to support multiple platforms, although there are implementation in most platforms but they are not up to date they are not maintained. So you should avoid using socket.io

>
Whenever youre creating a websocket server, youre actually creating a http server only. The first req that the browser sends is a http only. It gets upgraded to a websocket connection on the server. Whenever youre creating websocket server, there is a http server running under the hood.
>

Using ws to make wesocket server:
- Create a empty nodejs repo, npm init and tsc init.
- Install ws and @types/ws
- Code using http:
```ts
import WebSocket, { WebSocketServer } from 'ws';
import http from 'http';

const server = http.createServer(function(request: any, response: any) {
    console.log((new Date()) + ' Received request for ' + request.url);
    response.end("hi there");
});

const wss = new WebSocketServer({ server });
let userCount = 0;

wss.on('connection', function connection(ws) {
  ws.on('error', console.error);

  ws.on('message', function message(data, isBinary) {
    wss.clients.forEach(function each(client) {
      if (client.readyState === WebSocket.OPEN) {
        client.send(data, { binary: isBinary });
      }
    });
  });

  console.log("user connected ", ++userCount);
  ws.send('Hello! Message From Server!!');
});

server.listen(8080, function() {
    console.log((new Date()) + ' Server is listening on port 8080');
});
```

- Code using express: "npm install express @types/express"
```ts
import express from 'express'
import { WebSocketServer, WebSocket } from 'ws'

const app = express()
const httpServer = app.listen(8080)

const wss = new WebSocketServer({ server: httpServer });

wss.on('connection', function connection(socket) {
  socket.on('error', console.error);

  socket.on('message', function message(data, isBinary) {
    wss.clients.forEach(function each(client) {
      if (client.readyState === WebSocket.OPEN) {
        client.send(data, { binary: isBinary });
      }
    });
  });

  socket.send('Hello! Message From Server!!');
});
```
Websockets logic:
Anytime someone creates a connection:
control will reach on ws logic and you'll get access to ws instance, see callback function.
- Anytime there is a message then to every client that is currently connected, on the WebSocketServer, if the socket comnnection is open to them then send them the data. error and message are event registers.
- So whenever that is an incoming message, for every client that is currently connected, send them the same data that was sent by the end user. Very similar to a chat app, if one user sends you a msg, you broadcast it to everyone. Youre playing a multiplayer game then all the people need to know your action, like you move in game.

- To connect to websocket you need client or like postman. hoppscotch.io is same as postman, it lets you send http req, it also has realtime layer. There you can test the connection ws://localhost:8080 and track it in inspect network tab.
- You can open this link in two same tabs in hoppscotch and then play around.
- Very common way to build a multiplayer game/chat system.



#### Client Side Code
Websocket is a browser API that you can access (very similar to fetch). Will work in a raw project, React project and Next project (needs to be client side). To use it to the client side, we can use the websocket api.
- create vite app
- Then add Websocket logic to useEffect
- Websocket comes bundled in nodejs, like fetch
- Here's how we created the app:

```tsx
import { useEffect, useState } from 'react'
import './App.css'

function App() {
  const [socket, setSocket] = useState<null | WebSocket>(null);
  const [latestMessage, setLatestMessage] = useState("");
  const [message, setMessage] = useState("")

  useEffect(() => {
    const socket = new WebSocket('ws://localhost:8080');
    socket.onopen = () => {
      console.log('Connected');
      setSocket(socket);
    }
    socket.onmessage = (message) => {
      console.log('Recieved message: ', message.data);
      setLatestMessage(message.data);
    }

    return () => {
      socket.close();
    }
    
  },[])


  if(!socket) {
    return (
      <div>
        Connecting to socket server...
      </div>
    )
  }

  return (
    <>
    <input type="text" onChange={(e) => {
      setMessage(e.target.value);
    }}/>
    <button onClick={() => socket.send(message)}>Send</button>
      {latestMessage}
    </>
  )
}

export default App
```


**In Nextjs**
- Its same in nextjs too. Only thing to make sure is make sure its a client component. If you dont do that then your next server will create a connection to the websocket. But we want the client to create connection to the websocket server.















Two more protocols you kirat mentioned `quic` and `WebRTC` 

Where do you implement queue? in the backend itself or another server.
Its just a server thats running RabitMQ or Redis


