### How to Deploy Frontend on AWS

Any website you visit needs to send back some content, such as **HTML**, **CSS**, **JavaScript files**, or **media files** (images, videos, etc.). These files, which do not come from a database, are called **objects**. 

- **Objects:** Include files like images, videos, SVGs, and static assets.
- **Databases:** Used to store searchable data such as user information, video metadata, or todo lists.
- **Object Stores:** Specialized for storing objects/static files. AWS provides **S3 (Simple Storage Service)** as its object storage solution. Objects, we should never store them in the conventional databases. Any data we will search upon should be stored in databases. They should be stored in object stores. 

---

### **CDN (Content Delivery Network)**
- When files are stored in an object store, accessing them directly through an S3 URL is slow and expensive.
- A CDN distributes files efficiently across the globe using caching.
- AWS provides CloudFront, a popular CDN service, to work with S3.

- **S3 (Storage)**: Stores the files.
- **CloudFront (Distribution)**: Handles efficient delivery by caching at global POPs.
- **Backend Consideration**: Backend responses are user-specific, so caching in a CDN does not make sense. Instead, edge networks deploy backend services globally without caching.

**How CDNs Work:**
1. A file is stored in S3 (source of truth).
2. When a user requests the file, the request is routed to the nearest **Point of Presence (POP)** server via CloudFront.
3. If the POP server has a cached copy, it serves the file immediately.
4. If the file is not cached, the POP fetches it from S3, caches it, and serves it.
5. This process reduces latency and improves speed for subsequent requests.


CDN creates bunch of POPs(Point of presence). If anyone asks for somehting through the cloudfront url is when there request will be routed to the closest pop. If the pop has it already there it gives it, if it doesnt have it there it gets it from the S3 and caches it.

So we need not just an object store(used for storage) we also need a cdn(used for distribution). you are charged for both of them. Distribution is pritty higher charged.
You dont cache backend in pop, as data people fetch from backend is pretty user specific so it doesnt make sense to cache backend in cdn.

- For frontends, mp4 files, images, Object stores  + CDNs are a better approach.
- You can’t use the same for backends, since every request returns a different response. Caching doesn’t make any sense there. (You can use edge networks for backends (deploy your backend on various servers on the internet) but data can’t be cached in there.)


## Build your React frontend
>This approach will not work for frameworks that use Server side rendering (like Next.js)
This will work for basic React apps, HTML/CSS/JS apps
>


### Deployment Workflow

#### **1. Build Your React Frontend**
- Local react project, run `npm run dev`, it runs in developer mode. Thats not how you deploy the app on the internet, its just a bunch of html, css and js files is what we distribute. So we build the application to convert it.
- This approach works for **basic React apps** or **HTML/CSS/JS apps**.  
  **Note:** Server-side rendering frameworks like **Next.js** need a different setup.

1. Run `npm run dev` for local development.
2. Use `npm run build` to create production-ready files (dist folder).
3. To preview locally, install `serve`, it serves all the files in the folder in which you run the serve command:
```bash
npm install -g serve
cd dist
serve
```

---

#### **2. Create an Object Store on AWS**
1. Go to **S3** and create a **bucket** (logical storage container for files).
2. Upload the contents of the `dist` folder to the bucket.
3. **Block public access** to the bucket, as we dont want people to access things from S3, its expensive, its slow.

---

#### **3. Set Up CloudFront**
- **CloudFront** serves as the CDN to distribute files globally.

1. **Create a CloudFront Distribution:**
   - Go to CloudFront and create a new distribution.
   - Select your S3 bucket as the **source** (origin).

2. **Configure Origin Access Control (OAC):**
   - Enable OAC to ensure users access files only through CloudFront, not directly from S3.
   - Copy the policy generated by CloudFront and paste it into your S3 bucket permissions.

3. **Set Default Root Object:**
   - Specify `index.html` as the default root object.

---

#### **4. Connect CloudFront to Your Domain**
1. **Edit Alternate Domain Name:**
   - Add the custom domain name you own.
   
2. **Add SSL (for HTTPS):**
    - **Custom SSL certificate** - This is important if you want your final website to be deployed on https.
    - Amazon cannot create a certificate for any random domain, the certificate can only be created and deployed if you own that certificate. So you have to show amazon the ownership of that domain and then only amazon will create certificate for it.
    - Use **Amazon Certificate Manager (ACM)** to create an SSL certificate:
        - You go to wherever you have bought that certificate (eg. google domain) you go to dns and add **CNAME records** in your domain's DNS settings and value where it should point from amazon acm to the domain dns.
        - Once verified, attach the certificate to the CloudFront distribution.

3. **Update DNS Records:**
    - When you try to hit the domain then the aws cloudfront wont be able to serve it, we did the verification bit to the domain company (ef. google domain) but we didnt point the domain to the cloudfront url provided. So we add a new record and make the subdomain point to the cloudfront url.
    - Add a new DNS record in your domain provider (e.g., Google Domains).
    - Point the domain (or subdomain) to the CloudFront distribution URL.

---

**Now you have a https frontend on your own domain deployed on cloudfront backed by s3 which is a nice production way to deploy frontend applications specifically react or simple html, css and js app**

- Now lets say when you go to web.com/dashboard, it cant find a dashboard file in s3 so it doesnt know where to go. Ideally there is some client side routing out there and s3/cloudfront should always return index.html, even we go to whatever route the req should go to index.html and the js file should see and render that page accordingly. So you reach a error page by cloudfront, to make sure all req reach the index.html add error page that points to index.html
So in the s3 bucket we add error page and select 403 and customize error response and then return them back index.html with a 200 status code. So that when we use dynamic route then the indexx.html page runs which calls js and it figure out further.
Then go to Invalidation section, as the response to the route your trying to reach is cached and to make sure you clear the cache you create invalidation, in the field write "/*".

#### **5. Handle Dynamic Routes (Client-Side Routing)**
- React apps with dynamic routes (e.g., `/dashboard`) may break when accessed directly via CloudFront or S3.

**Solution:**
1. In the S3 bucket, configure a **custom error response**:
   - For **403 errors**, return `index.html` with a **200 status code**.
   - This ensures all requests reach `index.html`, allowing the React router to handle navigation.

2. **Invalidate Cache:**
   - If changes are made to the app, invalidate the CloudFront cache:
     - Go to the **Invalidation** section in CloudFront.
     - Create a new invalidation for `/*`.

---

### **Final Workflow Recap**
1. Build your React app and upload the `dist` folder to an S3 bucket.
2. Block public access to S3.
3. Create a CloudFront distribution with S3 as the origin.
4. Connect a custom domain to CloudFront and add an SSL certificate.
5. Configure S3 to handle dynamic routes using error pages.
6. Invalidate the CloudFront cache after updates.

---

### **Interview Tips**
- Be ready to explain:
  - The purpose of **object stores (S3)** and **CDNs (CloudFront)**.
  - Why **CDNs are critical for global performance**.
  - The difference between **backend caching** and **frontend static file caching**.
  - How to handle **dynamic routes** in client-side rendering apps.
  - Cost considerations of using S3 and CloudFront:
    - S3 charges for storage.
    - CloudFront charges for distribution.

- Practice explaining:
  - How to verify domain ownership via DNS.
  - The significance of **SSL certificates** for production-ready applications.
  - Why invalidation is necessary for CDN caches.
